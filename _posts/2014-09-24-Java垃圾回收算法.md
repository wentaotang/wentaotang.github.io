---
layout: post
title: Java垃圾回收算法
categories:
- 垃圾回收
tags:
- GC
---

## 引用计数法（Reference Counting）

 引用计数法是最经典的也是最古老的的垃圾收集算法，在微软的COM组件，Adobe的ActionScript中，都可以找到引用计算法的身影。
 
 **定义**：为每个对象分配一个整型的计算器，只要有任何对象引用了改对象，则计算器就加1，当应用失效时，引用计算器就减1.当对象的计算器的值为0时，则对象不可能再被使用。
 
 **缺陷**：该算法无法处理循环引用的问题。
 
## 标记-清除算法（Mark-Sweep）
 
  标记-清除算法将垃圾回收分为2个阶段：标记阶段和清除阶段。

  该算法的出现也是在`引用计数法`的基础上，解决了引用计数法无法处理的循环引用的问题，但是该算法也有弊端，就是`空间碎片`的问题。空间碎片的造成内存空间地址不是连续的，这就容易造成大对象在内存空间上分配效率低下。


## 复制算法（Copying）

**原理**：把内存空间分为2块，每次只使用其中一块，在垃圾回收时，将正在使用的内存对象中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存中的全部对象，交换内存的2个角色。

该算法是在`标记-清除`算法的基础上发展而来的，主要是为了解决`标记-清除`算法的内存空间碎片问题，但是该算法也有一个弊端，就是将系统空间折半了。

**使用场景**：既然是是采用复制的方法，所以如果是大量的对象需要复制，那么该算法的效率肯定比较低下，所以在算法适合在存活对象比较少的内存区域中使用，没错，复制算法比较适用于新生代，在新生代，垃圾对象严重多余存活对象，要负责的的存活对象非常少，所以效率非常也比较高。


## 标记-压缩算法(Mark-Compact)

复制算法的高效性是建立在存活对象少，垃圾对象多的前提下的，这这种情况在年轻代经常发生。但是在老年代，大部分情况是大部分对象都是存活的，很显然`复制算法`不再合适，基于该特性，`标记-压缩算法`应运而生，`标记-压缩算法`是在`标记-清除`算法的基础上优化而来的。

**原理**：该算法也需要从根节点开始，对所有可达节点做一次标记，但之后，它并不是简单的清除的未标记的对象，而是将所有可达的存活对象压缩到内存的一端，然后再清理边界外的所有空间。这种算法既避免的内存碎片的产生，也不需要折半内存空间。因此性价比比较高，适合在用于老年代空间。



[参考]

1. 【Java程序性能优化指南】
2. 【深入理解JVM虚拟机】